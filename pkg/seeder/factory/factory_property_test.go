package factory

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"pgregory.net/rapid"
)

// Feature: go-migration, Property 27: Factory produces populated instances
// **Validates: Requirements 13.2**
//
// For any factory definition, Make() should return an instance where all
// defined fields have non-zero values generated by the Faker.
func TestProperty27_FactoryProducesPopulatedInstances(t *testing.T) {
	rapid.Check(t, func(t *rapid.T) {
		seed := rapid.Int64().Draw(t, "seed")
		faker := NewFaker(seed)

		f := NewFactory(func(fk Faker) User {
			return User{
				Name:  fk.Name(),
				Email: fk.Email(),
				Age:   fk.IntBetween(1, 120),
			}
		}).WithFaker(faker)

		user := f.Make()

		assert.NotEmpty(t, user.Name, "Name should be non-zero")
		assert.NotEmpty(t, user.Email, "Email should be non-zero")
		assert.NotZero(t, user.Age, "Age should be non-zero")
	})
}

// Feature: go-migration, Property 28: Factory state overrides merge correctly
// **Validates: Requirements 13.3**
//
// For any factory with a default definition and a named state, applying the
// state should override exactly the fields specified in the state while
// preserving all other default values.
func TestProperty28_FactoryStateOverridesMergeCorrectly(t *testing.T) {
	rapid.Check(t, func(t *rapid.T) {
		seed := rapid.Int64().Draw(t, "seed")
		overrideName := rapid.StringMatching(`[A-Z][a-z]{2,10} [A-Z][a-z]{2,10}`).Draw(t, "overrideName")

		faker := NewFaker(seed)

		f := NewFactory(func(fk Faker) User {
			return User{
				Name:  fk.Name(),
				Email: fk.Email(),
				Age:   fk.IntBetween(18, 65),
			}
		}).WithFaker(faker)

		f.State("custom", func(fk Faker, base User) User {
			base.Name = overrideName
			return base
		})

		// Get a baseline from the same seed (no state applied)
		baselineFaker := NewFaker(seed)
		baseline := NewFactory(func(fk Faker) User {
			return User{
				Name:  fk.Name(),
				Email: fk.Email(),
				Age:   fk.IntBetween(18, 65),
			}
		}).WithFaker(baselineFaker).Make()

		// Apply state
		result := f.WithState("custom").Make()

		// Overridden field should match the override value
		assert.Equal(t, overrideName, result.Name, "Name should be overridden by state")
		// Non-overridden fields should match the baseline (same seed, same definition)
		assert.Equal(t, baseline.Email, result.Email, "Email should be preserved from default")
		assert.Equal(t, baseline.Age, result.Age, "Age should be preserved from default")
	})
}

// Feature: go-migration, Property 29: MakeMany returns exactly N instances
// **Validates: Requirements 13.4**
//
// For any positive integer N, MakeMany(N) should return a slice of exactly N instances.
func TestProperty29_MakeManyReturnsExactlyNInstances(t *testing.T) {
	rapid.Check(t, func(t *rapid.T) {
		n := rapid.IntRange(1, 100).Draw(t, "n")
		seed := rapid.Int64().Draw(t, "seed")
		faker := NewFaker(seed)

		f := NewFactory(func(fk Faker) User {
			return User{
				Name:  fk.Name(),
				Email: fk.Email(),
				Age:   fk.IntBetween(18, 65),
			}
		}).WithFaker(faker)

		results := f.MakeMany(n)

		assert.Len(t, results, n, "MakeMany should return exactly N instances")

		// Each instance should be populated
		for i, u := range results {
			assert.NotEmpty(t, u.Name, "Instance %d Name should be non-empty", i)
			assert.NotEmpty(t, u.Email, "Instance %d Email should be non-empty", i)
			assert.NotZero(t, u.Age, "Instance %d Age should be non-zero", i)
		}
	})
}

// Feature: go-migration, Property 30: Faker generates values within specified ranges
// **Validates: Requirements 13.5**
//
// For any min and max integers where min <= max, Faker.IntBetween(min, max)
// should return a value v where min <= v <= max.
// Similarly for Float64Between.
func TestProperty30_FakerGeneratesValuesWithinSpecifiedRanges(t *testing.T) {
	t.Run("IntBetween", func(t *testing.T) {
		rapid.Check(t, func(t *rapid.T) {
			seed := rapid.Int64().Draw(t, "seed")
			min := rapid.IntRange(-1000, 1000).Draw(t, "min")
			max := rapid.IntRange(min, min+1000).Draw(t, "max")

			faker := NewFaker(seed)
			v := faker.IntBetween(min, max)

			assert.GreaterOrEqual(t, v, min, "IntBetween result should be >= min")
			assert.LessOrEqual(t, v, max, "IntBetween result should be <= max")
		})
	})

	t.Run("Float64Between", func(t *testing.T) {
		rapid.Check(t, func(t *rapid.T) {
			seed := rapid.Int64().Draw(t, "seed")
			min := rapid.Float64Range(-1000.0, 1000.0).Draw(t, "min")
			max := rapid.Float64Range(min, min+1000.0).Draw(t, "max")

			faker := NewFaker(seed)
			v := faker.Float64Between(min, max)

			assert.GreaterOrEqual(t, v, min, "Float64Between result should be >= min")
			assert.LessOrEqual(t, v, max, "Float64Between result should be <= max")
		})
	})
}
